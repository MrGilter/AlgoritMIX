<?xml version="1.0" encoding="utf-8" ?>
<root>
  <Sorting name ="Bubble sort">
    <text>
      Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован. Заметим, что после первой итерации самый большой элемент будет находиться в конце массива, на правильном месте. После двух итераций на правильном месте будут стоять два наибольших элемента, и так далее. Очевидно, не более чем после n итераций массив будет отсортирован. Таким образом, асимптотика в худшем и среднем случае – O(n^2), в лучшем случае – O(n).
    </text>
    <algorithm_complexity>
      Сложность:  O(n), в худшем - O(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Gnome sort">
    <text>
      Алгоритм гномьей сортировки разработан, по словам официального автора(Дика Груна), гномами, которые сортировали садовые горшки. Правда это или нет, но алгоритм очень прост, особенно для начинающих. По сути, в алгоритме сравниваются рядом стоящие горшки, если они стоят в нужном порядке, тогда мы переходим на следующий элемент массива, если нет, ты мы их переставляем и переходим на предыдущий. Нету предыдущего элемента — идём вперед, нету следующего — значит мы закончили. Изначально мы находимся на втором элементе массива.

      Если в двух совах то текущий элемент сравниваеться с следующим если следующий элемент меньше текущего то меняем местами и указатель текущего элемента уменьшаем на еденицу. В итоге если при уменьшении указателя мы пришли в начало то начинаем поиск наново и так пока не будет прохода без перестановок, если указатель в конце масива то завершаем.
      Данный алгоритм иногда спрашивают на собеседованиях  -  как можно отсортировать масив за один проход? Так как в реализации данного масива используеться только один цикл и  данный цыкл будет работать только один проход так как внутри цыкла мы смещаем указатель елемента на -1 (тоесть пока алгоритм полностью не отсортирует массив то первый и единственный проход цыкла не закончится).
    </text>
    <algorithm_complexity>
      Сложность:  O(n), в худшем – O(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Comb sort">
    <text>
      Comb sort - алгоритм сортировки, основанный на сравнении , который улучшает пузырьковую сортировку .
      В пузырьковой сортировке соседние элементы сравниваются для сортировки массива, поэтому разрыв между сравниваемыми элементами равен 1.
      Комбинированная сортировка использует больший разрыв и работает над стратегией пузырьковой сортировки . Мы определяем переменную промежутка и элементы, разделенные пробелом, сравниваются и меняются местами, чтобы получить отсортированный порядок элементов. Разрыв инициализируется как размер массива, и после каждой итерации разрыв уменьшается на коэффициент сжатия, как описано в следующих шагах алгоритма. Итерация продолжается до тех пор, пока разрыв не станет равным 1. Таким образом, последняя итерация этого алгоритма такая же, как итерация с пузырьковой сортировкой.

      Оптимальное значение фактора уменьшения 1,247... (1.3)
    </text>
    <algorithm_complexity>
      Сложность:  O(nlogn), в худшем – O(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Insertion sort">
    <text>
      Общая суть сортировок вставками такова:

      Перебираются элементы в неотсортированной части массива.
      Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.

      Это, в принципе, всё, что Вам нужно знать про сортировки вставками. То есть, сортировки вставками всегда делят массив на 2 части — отсортированную и неотсортированную. Из неотсортированной части извлекается любой элемент. Поскольку другая часть массива отсортирована, то в ней достаточно быстро можно найти своё место для этого извлечённого элемента. Элемент вставляется куда нужно, в результате чего отсортированная часть массива увеличивается, а неотсортированная уменьшается. Всё. По такому принципу работают все сортировки вставками.

      Самое слабое место в этом подходе — вставка элемента в отсортированную часть массива. На самом деле это непросто и на какие только ухищрения не приходится идти, чтобы выполнить этот шаг.
      Проходим по массиву слева направо и обрабатываем по очереди каждый элемент. Слева от очередного элемента наращиваем отсортированную часть массива, справа по мере процесса потихоньку испаряется неотсортированная. В отсортированной части массива ищется точка вставки для очередного элемента. Сам элемент отправляется в буфер, в результате чего в массиве появляется свободная ячейка — это позволяет сдвинуть элементы и освободить точку вставки.
      
    </text>
    <algorithm_complexity>
      Сложность:  O(n), в среднем и худшем случае – O(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Shell sort">
    <text>
      Сортируем вставкой подгруппы элементов, но только в подгруппе они идут не в ряд, а равномерно выбираются с некоторой дельтой по индексу. После первоначальных грубых проходов, дельта методично уменьшается, пока расстояние между элементами этих несвязных подмножеств не достигнет единицы. Благодаря первоначальным проходам с большим шагом, большинство малых по значению элементов перебрасываются в левую часть массива, большинство крупных элементов массива попадают в правую.

      Как известно, вставочный метод очень эффективно обрабатывает почти отсортированные массивы. Сортировка Шелла при первоначальных проходах достаточно быстро и доводит массив к состоянию неполной упорядоченности. На заключительном этапе шаг равен единице, т.е. "Шелл" естественным образом трансформируется в сортировку простыми вставками.

      Пример:
      Идея метода заключается в сравнение разделенных на группы элементов последовательности, находящихся друг от друга на некотором расстоянии. Изначально это расстояние равно d или N/2, где N — общее число элементов. На первом шаге каждая группа включает в себя два элемента расположенных друг от друга на расстоянии N/2; они сравниваются между собой, и, в случае необходимости, меняются местами. На последующих шагах также происходят проверка и обмен, но расстояние d сокращается на d/2, и количество групп, соответственно, уменьшается. Постепенно расстояние между элементами уменьшается, и на d=1 проход по массиву происходит в последний раз.
      Первое значение, соответствующее расстоянию d равно 10/2=5. На каждом шаге оно уменьшается вдвое. Элементы, входящие в одну группу, сравниваются и если значение какого-либо элемента, стоящего левее того с которым он сравнивается, оказывается больше (сортировка по возрастанию), тогда они меняются местами. Так, элементы путем внутригрупповых перестановок постепенно становятся на свои позиции, и на последнем шаге (d=1) сортировка сводится к проходу по одной группе, включающей в себя все N элементов массива. При этом число требуемых обменов оказывается совсем небольшим.
      
    </text>
    <algorithm_complexity>
      Сложность: O(n log˅2 n), в худшем случае - O(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Tree sort">
    <text>
      Сортировка бинарным деревом (в текущем програмном коде используеться бинарное древо без балансировки). Сначала строится бинарное древо на основе входящго масива, потом когда дерево заполнено делаем обход в ширину.
      Процедура добавления объекта в бинарное дерево имеет среднюю алгоритмическую сложность порядка O(log(n)). Соответственно, для n объектов сложность будет составлять O(n log(n)), что относит сортировку с помощью двоичного дерева к группе «быстрых сортировок». Однако, сложность добавления объекта в разбалансированное дерево может достигать O(n), что может привести к общей сложности порядка O(n²).
    </text>
    <algorithm_complexity>
      Сложность:  O(n log(n)), в худшем - O(n²).
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Selection sort">
    <text>
      Шаги алгоритма:

      находим номер минимального значения в текущем списке
      производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции)
      теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы
      Для реализации устойчивости алгоритма необходимо в пункте 2 минимальный элемент непосредственно вставлять в первую неотсортированную позицию, не меняя порядок остальных элементов.
    </text>
    <algorithm_complexity>
      Сложность:  О(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Heap sort">
    <text>
      Поскольку двоичная куча - это полное двоичное дерево, ее можно легко представить в виде массива, а представление на основе массива экономит место. Если родительский узел хранится в индексе I, левый дочерний элемент может быть вычислен как 2 * I + 1, а правый дочерний элемент - как 2 * I + 2 (при условии, что индексирование начинается с 0).

      Алгоритм сортировки кучи для сортировки по возрастанию:
      1. Построить максимальную кучу из входных данных.
      2. В этот момент самый большой элемент хранится в корне кучи. Замените его на последний элемент кучи, а затем уменьшите размер кучи на 1. Наконец, наведите корень дерева.
      3. Повторите вышеуказанные шаги, пока размер кучи больше 1.
    </text>
    <algorithm_complexity>
      O(n log n)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Shaker sort">
    <text>
      (также известна как сортировка перемешиванием и коктейльная сортировка). Заметим, что сортировка пузырьком работает медленно на тестах, в которых маленькие элементы стоят в конце (их еще называют «черепахами»). Такой элемент на каждом шаге алгоритма будет сдвигаться всего на одну позицию влево. Поэтому будем идти не только слева направо, но и справа налево. Будем поддерживать два указателя begin и end, обозначающих, какой отрезок массива еще не отсортирован. На очередной итерации при достижении end вычитаем из него единицу и движемся справа налево, аналогично, при достижении begin прибавляем единицу и двигаемся слева направо. Асимптотика у алгоритма такая же, как и у сортировки пузырьком, однако реальное время работы лучше.
    </text>
    <algorithm_complexity>
      Сложность: O(n), в худшем - O(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Quick sort">
    <text>
      Выберем некоторый опорный элемент. После этого перекинем все элементы, меньшие его, налево, а большие – направо. Рекурсивно вызовемся от каждой из частей. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. Асимптотика: O(nlogn) в среднем и лучшем случае, O(n2). Наихудшая оценка достигается при неудачном выборе опорного элемента
    </text>
    <algorithm_complexity>
      Сложность: O(n log n), в худшем случае - O(n^2)
    </algorithm_complexity>
  </Sorting>
  <Sorting name ="Radix LSD">
    <text>
      Элементы перебираются по порядку и группируются по самому младшему разряду (сначала все, заканчивающиеся на 0, затем заканчивающиеся на 1, ..., заканчивающиеся на 9). Возникает новая последовательность. Затем группируются по следующему разряду с конца, затем по следующему и т.д. пока не будут перебраны все разряды, от младших к старшим.
    </text>
    <algorithm_complexity>
      Сложность: O(wn), n = размер ввода, w = размер слова.
    </algorithm_complexity>
  </Sorting>
</root>